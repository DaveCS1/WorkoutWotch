// -----------------------------------------------------------------------
// <autogenerated>
//    This code was generated from a template.
// 
//    Changes to this file may cause incorrect behaviour and will be lost
//    if the code is regenerated.
// </autogenerated>
// ------------------------------------------------------------------------
namespace WorkoutWotch.UnitTests.Services.Logger.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class LoggerServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Logger.ILoggerService>, global::WorkoutWotch.Services.Contracts.Logger.ILoggerService
    {
        public LoggerServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::WorkoutWotch.Services.Contracts.Logger.LogLevel Threshold
        {
            get
            {
                return this.Apply(x => x.Threshold);
            }

            set
            {
                this.ApplyPropertySet(x => x.Threshold, value);
            }
        }

        public System.Boolean IsDebugEnabled
        {
            get
            {
                return this.Apply(x => x.IsDebugEnabled);
            }
        }

        public System.Boolean IsInfoEnabled
        {
            get
            {
                return this.Apply(x => x.IsInfoEnabled);
            }
        }

        public System.Boolean IsPerfEnabled
        {
            get
            {
                return this.Apply(x => x.IsPerfEnabled);
            }
        }

        public System.Boolean IsWarnEnabled
        {
            get
            {
                return this.Apply(x => x.IsWarnEnabled);
            }
        }

        public System.Boolean IsErrorEnabled
        {
            get
            {
                return this.Apply(x => x.IsErrorEnabled);
            }
        }

        public global::System.IObservable<global::WorkoutWotch.Services.Contracts.Logger.LogEntry> Entries
        {
            get
            {
                return this.Apply(x => x.Entries);
            }
        }

        public global::WorkoutWotch.Services.Contracts.Logger.ILogger GetLogger(global::System.Type forType)
        {
            return this.Apply(x => x.GetLogger(forType));
        }

        public global::WorkoutWotch.Services.Contracts.Logger.ILogger GetLogger(System.String name)
        {
            return this.Apply(x => x.GetLogger(name));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Logger.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class LoggerMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Logger.ILogger>, global::WorkoutWotch.Services.Contracts.Logger.ILogger
    {
        public LoggerMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public System.String Name
        {
            get
            {
                return this.Apply(x => x.Name);
            }
        }

        public System.Boolean IsDebugEnabled
        {
            get
            {
                return this.Apply(x => x.IsDebugEnabled);
            }
        }

        public System.Boolean IsInfoEnabled
        {
            get
            {
                return this.Apply(x => x.IsInfoEnabled);
            }
        }

        public System.Boolean IsPerfEnabled
        {
            get
            {
                return this.Apply(x => x.IsPerfEnabled);
            }
        }

        public System.Boolean IsWarnEnabled
        {
            get
            {
                return this.Apply(x => x.IsWarnEnabled);
            }
        }

        public System.Boolean IsErrorEnabled
        {
            get
            {
                return this.Apply(x => x.IsErrorEnabled);
            }
        }

        public void Debug(System.String message)
        {
            this.Apply(x => x.Debug(message));
        }

        public void Debug(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Debug(format, args));
        }

        public void Debug(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Debug(exception, format, args));
        }

        public void Info(System.String message)
        {
            this.Apply(x => x.Info(message));
        }

        public void Info(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Info(format, args));
        }

        public void Info(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Info(exception, format, args));
        }

        public global::System.IDisposable Perf(System.String message)
        {
            return this.Apply(x => x.Perf(message));
        }

        public global::System.IDisposable Perf(System.String format, System.Object[] args)
        {
            return this.Apply(x => x.Perf(format, args));
        }

        public void Warn(System.String message)
        {
            this.Apply(x => x.Warn(message));
        }

        public void Warn(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Warn(format, args));
        }

        public void Warn(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Warn(exception, format, args));
        }

        public void Error(System.String message)
        {
            this.Apply(x => x.Error(message));
        }

        public void Error(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Error(format, args));
        }

        public void Error(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Error(exception, format, args));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Scheduler.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class SchedulerServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Scheduler.ISchedulerService>, global::WorkoutWotch.Services.Contracts.Scheduler.ISchedulerService
    {
        public SchedulerServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Reactive.Concurrency.IScheduler DefaultScheduler
        {
            get
            {
                return this.Apply(x => x.DefaultScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler CurrentThreadScheduler
        {
            get
            {
                return this.Apply(x => x.CurrentThreadScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler ImmediateScheduler
        {
            get
            {
                return this.Apply(x => x.ImmediateScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler SynchronizationContextScheduler
        {
            get
            {
                return this.Apply(x => x.SynchronizationContextScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler TaskPoolScheduler
        {
            get
            {
                return this.Apply(x => x.TaskPoolScheduler);
            }
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.State.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class StateServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.State.IStateService>, global::WorkoutWotch.Services.Contracts.State.IStateService
    {
        public StateServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Threading.Tasks.Task<T> GetAsync<T>(System.String key)
        {
            return this.Apply(x => x.GetAsync<T>(key));
        }

        public global::System.Threading.Tasks.Task SetAsync<T>(System.String key, T value)
        {
            return this.Apply(x => x.SetAsync<T>(key, value));
        }

        public global::System.Threading.Tasks.Task RemoveAsync<T>(System.String key)
        {
            return this.Apply(x => x.RemoveAsync<T>(key));
        }

        public global::System.Threading.Tasks.Task SaveAsync()
        {
            return this.Apply(x => x.SaveAsync());
        }

        public global::System.IDisposable RegisterSaveCallback(global::System.Func<global::WorkoutWotch.Services.Contracts.State.IStateService, global::System.Threading.Tasks.Task> saveTaskFactory)
        {
            return this.Apply(x => x.RegisterSaveCallback(saveTaskFactory));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Delay.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class DelayServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Delay.IDelayService>, global::WorkoutWotch.Services.Contracts.Delay.IDelayService
    {
        public DelayServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Threading.Tasks.Task DelayAsync(global::System.TimeSpan duration, global::System.Threading.CancellationToken cancellationToken)
        {
            return this.Apply(x => x.DelayAsync(duration, cancellationToken));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.ExerciseDocument.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class ExerciseDocumentServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.ExerciseDocument.IExerciseDocumentService>, global::WorkoutWotch.Services.Contracts.ExerciseDocument.IExerciseDocumentService
    {
        public ExerciseDocumentServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<System.String> ExerciseDocument
        {
            get
            {
                return this.Apply(x => x.ExerciseDocument);
            }
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Audio.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class AudioServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Audio.IAudioService>, global::WorkoutWotch.Services.Contracts.Audio.IAudioService
    {
        public AudioServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Threading.Tasks.Task PlayAsync(System.String resourceUri)
        {
            return this.Apply(x => x.PlayAsync(resourceUri));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Speech.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class SpeechServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Speech.ISpeechService>, global::WorkoutWotch.Services.Contracts.Speech.ISpeechService
    {
        public SpeechServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Threading.Tasks.Task SpeakAsync(System.String speechString, global::System.Threading.CancellationToken cancellationToken)
        {
            return this.Apply(x => x.SpeakAsync(speechString, cancellationToken));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Container.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class ContainerServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Container.IContainerService>, global::WorkoutWotch.Services.Contracts.Container.IContainerService
    {
        public ContainerServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public T Resolve<T>()where T : class
        {
            return this.Apply(x => x.Resolve<T>());
        }
    }
}

